<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Die Poller-Pumper (Mobile) - Johannes Heinrich 2025</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            font-family: 'Press Start 2P', cursive;
            color: white;
            overflow: hidden; /* Prevent scrolling */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Prevent browser zooming/panning */
        }

        #game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            position: relative;
            width: 100%;
            max-width: 800px;
        }

        #game-container {
            position: relative;
            width: 100%;
            /* Maintain Aspect Ratio 8:5 using padding hack or aspect-ratio property */
            aspect-ratio: 8/5;
            background: #1a1a1a;
            border-top: 2px solid #c0392b;
            border-bottom: 2px solid #c0392b;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            overflow: hidden;
            cursor: pointer;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            text-shadow: 1px 1px 0 #000;
            font-size: 10px; /* Smaller font for mobile */
            width: 100%;
        }

        .weihnachts-meter-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .weihnachts-meter {
            width: 80px; /* Smaller meter */
            height: 10px;
            background: #555;
            border: 1px solid white;
            position: relative;
        }

        .meter-fill {
            width: 100%;
            height: 100%;
            background: #27ae60;
            transition: width 0.2s, background-color 0.2s;
        }

        #legend {
            width: 100%;
            background: rgba(0,0,0,0.8);
            border: 1px solid #7f8c8d;
            padding: 5px;
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            justify-content: space-around;
            font-size: 8px; /* Very small font */
            box-sizing: border-box;
            gap: 5px;
        }

        .legend-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            min-width: 30%;
        }
        .legend-icons {
            font-size: 14px;
        }
        .good { color: #2ecc71; }
        .bad { color: #e74c3c; }
        .neutral { color: #f1c40f; }

        #footer {
            margin-top: 5px;
            font-size: 8px;
            color: #bdc3c7;
            text-align: center;
            width: 100%;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            pointer-events: auto;
            padding: 10px;
            box-sizing: border-box;
        }

        h1 { color: #e74c3c; line-height: 1.4; font-size: 16px; margin-bottom: 5px;}
        h2 { color: #f1c40f; font-size: 12px; margin-bottom: 10px; }
        p { font-size: 8px; line-height: 1.6; max-width: 90%; margin-bottom: 10px; color: #ccc; }

        .rules-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
            text-align: left;
            font-size: 8px;
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
            width: 90%;
        }
        
        .rules-column h3 { color: #f1c40f; margin: 0 0 5px 0; font-size: 9px; border-bottom: 1px solid #555; padding-bottom: 2px;}
        .rules-item { margin-bottom: 2px; display: flex; align-items: center; }
        .emoji-icon { width: 15px; display: inline-block; font-size: 12px; text-align: center;}

        button {
            background: #27ae60;
            color: white;
            border: none;
            padding: 15px 20px; /* Larger touch target */
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            cursor: pointer;
            border-bottom: 4px solid #1e8449;
            transition: transform 0.1s;
            border-radius: 5px;
            touch-action: manipulation;
        }

        button:active {
            transform: translateY(4px);
            border-bottom: none;
        }

        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }
        .hidden { display: none !important; }

        /* Orientation Warning (Optional aesthetic touch) */
        @media (orientation: portrait) {
            #game-container {
                border-left: none;
                border-right: none;
            }
        }

    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="game-container">
        <!-- Internal resolution remains 800x500 for logic consistency -->
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        
        <div id="ui-layer">
            <div class="hud-top">
                <div>LVL:<span id="level-display">1</span> SCR:<span id="score-display">0</span></div>
                <div class="weihnachts-meter-container">
                    LAUNE:
                    <div class="weihnachts-meter">
                        <div id="mood-fill" class="meter-fill"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="start-screen">
            <h1>POLLER-PUMPER<br>MOBILE</h1>
            
            <div class="rules-grid">
                <div class="rules-column">
                    <h3 style="color:#2ecc71">DURCHLASSEN (TAP)</h3>
                    <div class="rules-item"><span class="emoji-icon">üöã</span> Tram</div>
                    <div class="rules-item"><span class="emoji-icon">üç∑</span> Essen/Wein</div>
                    <div class="rules-item"><span class="emoji-icon">üéÅ</span> Geschenke</div>
                    <div class="rules-item"><span class="emoji-icon">üëº</span> Christkind</div>
                </div>
                <div class="rules-column">
                    <h3 style="color:#e74c3c">STOPPEN (ZU)</h3>
                    <div class="rules-item"><span class="emoji-icon">üç∫</span> Suffkis</div>
                    <div class="rules-item"><span class="emoji-icon">üë∫</span> Diebe</div>
                    <div class="rules-item"><span class="emoji-icon">üëπ</span> Griesgrame</div>
                </div>
            </div>

            <p>
                Tippe auf die Poller!<br>
                Tipp: Handy drehen!
            </p>
            <button id="start-btn" class="blink">STARTEN</button>
        </div>

        <div id="game-over-screen" class="hidden">
            <h1>SCHICHTENDE!</h1>
            <h2 id="final-reason">...</h2>
            <p>Score: <span id="final-score">0</span></p>
            <button id="restart-btn">NEUSTART</button>
        </div>
    </div>

    <div id="legend">
        <div class="legend-section">
            <span class="good">DURCHLASSEN</span>
            <div class="legend-icons">üöãüç∑üéÅüëº</div>
        </div>
        <div class="legend-section">
            <span class="bad">STOPPEN</span>
            <div class="legend-icons">üç∫üë∫üëπüó£Ô∏è</div>
        </div>
    </div>

    <!-- Fusszeile -->
    <div id="footer">Johannes Heinrich 2025 (Mobile Edition)</div>
</div>

<script>
    /**
     * MOBILE GAME CONFIGURATION & STATE
     */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Game State
    let gameRunning = false;
    let score = 0;
    let mood = 100;
    let level = 1;
    let eventsCount = 0;
    let frameCount = 0;
    let lastTime = 0;

    // Entities
    let workers = [];
    let bollards = [];
    let entities = [];
    let particles = [];

    // Assets
    const ASSETS = {
        good: [
            { sprite: 'üöã', name: 'Tram' },
            { sprite: 'üç™', name: 'Lebkuchen' },
            { sprite: 'üéÅ', name: 'Geschenk' },
            { sprite: 'üç∑', name: 'Gl√ºhwein' },
            { sprite: 'üëº', name: 'Christkind' },
            { sprite: 'üéÖ', name: 'Santa' }
        ],
        bad: [
            { sprite: 'üç∫', name: 'Betrunkener' },
            { sprite: 'üó£Ô∏è', name: 'Schwurbler' },
            { sprite: 'üë∫', name: 'Dieb' },
            { sprite: 'üëπ', name: 'Griesgram' } 
        ],
        jump: [
            { sprite: 'ü¶å', name: 'Rentier' }
        ],
        worker: 'üë∑',
        workerBusy: 'üèóÔ∏è',
        bollardClosed: 'üóø',
        bollardOpen: 'üï≥Ô∏è'
    };

    // Constants
    const TRACK_Y_1 = 180;
    const TRACK_Y_2 = 350;
    const LEFT_BOLLARD_X = 200;
    const RIGHT_BOLLARD_X = 600;
    const MARKET_CENTER_X = 400;
    const WORKER_SPEED = 8;
    const PUMP_TIME = 30; 
    
    // Audio Context
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'click') {
            osc.frequency.setValueAtTime(300, now);
            osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
            gainNode.gain.setValueAtTime(0.05, now);
            gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'pump') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(60, now);
            gainNode.gain.setValueAtTime(0.05, now);
            gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'crash') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.exponentialRampToValueAtTime(20, now + 0.4);
            gainNode.gain.setValueAtTime(0.2, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
            osc.start(now); osc.stop(now + 0.4);
        } else if (type === 'success') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(500, now);
            osc.frequency.setValueAtTime(1000, now + 0.1);
            gainNode.gain.setValueAtTime(0.05, now);
            gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(now); osc.stop(now + 0.2);
        } else if (type === 'levelup') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(300, now);
            osc.frequency.setValueAtTime(400, now + 0.1);
            osc.frequency.setValueAtTime(500, now + 0.2);
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.linearRampToValueAtTime(0, now + 0.4);
            osc.start(now); osc.stop(now + 0.4);
        } else if (type === 'arrive') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.linearRampToValueAtTime(800, now + 0.2);
            gainNode.gain.setValueAtTime(0.05, now);
            gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        }
    }

    /**
     * CLASSES
     */

    class Bollard {
        constructor(x, y, id) {
            this.x = x;
            this.y = y;
            this.id = id;
            this.state = 'CLOSED'; 
            this.progress = 0;
            this.workingWorker = null;
        }

        draw() {
            ctx.fillStyle = this.state === 'OPEN' ? '#27ae60' : '#7f8c8d';
            if (this.state === 'OPENING' || this.state === 'CLOSING') ctx.fillStyle = '#f39c12';
            
            if (this.progress > 0) {
                ctx.fillStyle = '#f1c40f';
                ctx.fillRect(this.x - 20, this.y - 45, 40, 6);
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(this.x - 20, this.y - 45, 40 * (this.progress / PUMP_TIME), 6);
            }

            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            let sprite = (this.state === 'CLOSED' || this.state === 'CLOSING') ? ASSETS.bollardClosed : ASSETS.bollardOpen;
            ctx.fillText(sprite, this.x, this.y);
            
            ctx.fillStyle = '#ecf0f1';
            ctx.font = '8px "Press Start 2P"';
            ctx.fillText(this.state === 'CLOSED' ? "ZU" : "AUF", this.x, this.y + 25);
        }
    }

    class Worker {
        constructor(id, startX, startY) {
            this.id = id;
            this.x = startX;
            this.y = startY;
            this.targetX = startX;
            this.targetY = startY;
            this.targetBollard = null;
            this.state = 'IDLE'; 
        }

        assignTask(bollard) {
            this.targetBollard = bollard;
            this.targetX = bollard.x;
            this.targetY = bollard.y - 20; 
            this.state = 'MOVING';
            bollard.workingWorker = this;
        }

        update() {
            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist > WORKER_SPEED) {
                this.x += (dx / dist) * WORKER_SPEED;
                this.y += (dy / dist) * WORKER_SPEED;
            } else {
                this.x = this.targetX;
                this.y = this.targetY;
                if (this.targetBollard && this.state === 'MOVING') {
                    this.state = 'PUMPING';
                }
            }

            if (this.state === 'PUMPING' && this.targetBollard) {
                let b = this.targetBollard;
                if (b.state === 'CLOSED') b.state = 'OPENING';
                if (b.state === 'OPEN') b.state = 'CLOSING';

                if (b.state === 'OPENING' || b.state === 'CLOSING') {
                    b.progress++;
                    if (frameCount % 5 === 0) playSound('pump');
                    
                    if (b.progress >= PUMP_TIME) {
                        b.state = (b.state === 'OPENING') ? 'OPEN' : 'CLOSED';
                        b.progress = 0;
                        b.workingWorker = null;
                        this.state = 'IDLE';
                        this.targetBollard = null;
                    }
                }
            }
        }

        draw() {
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            let sprite = this.state === 'PUMPING' ? ASSETS.workerBusy : ASSETS.worker;
            let offset = (this.state === 'MOVING' || this.state === 'PUMPING') ? Math.sin(frameCount * 0.5) * 3 : 0;
            ctx.fillText(sprite, this.x, this.y + offset);
        }
    }

    class GameEntity {
        constructor() {
            this.lane = Math.floor(Math.random() * 2);
            this.y = this.lane === 0 ? TRACK_Y_1 : TRACK_Y_2;

            let dir = Math.floor(Math.random() * 2);
            this.direction = dir === 0 ? 1 : -1;
            this.x = dir === 0 ? -50 : canvas.width + 50;

            let rand = Math.random();
            if (rand < 0.1) {
                this.category = 'jump';
                this.data = ASSETS.jump[0];
            } else if (rand < 0.55) {
                this.category = 'good';
                this.data = ASSETS.good[Math.floor(Math.random() * ASSETS.good.length)];
            } else {
                this.category = 'bad';
                this.data = ASSETS.bad[Math.floor(Math.random() * ASSETS.bad.length)];
            }

            let baseSpeed = 1.5 + ((level - 1) * 0.2);
            if (this.data.name === 'Tram') baseSpeed *= 0.7; 
            
            this.speed = baseSpeed;
            this.dead = false;
        }

        update() {
            if (this.dead) return;
            this.x += this.speed * this.direction;

            // Market Arrival Logic
            if (this.category === 'good' && this.data.name !== 'Tram') {
                let distToCenter = Math.abs(this.x - MARKET_CENTER_X);
                if (distToCenter < 10) {
                    this.handleMarketArrival();
                    return;
                }
            }

            // Bollard Collision Logic
            let myBollards = bollards.filter(b => Math.abs(b.y - this.y) < 20);
            myBollards.sort((a,b) => a.x - b.x); 
            
            if (this.category !== 'jump') {
                myBollards.forEach(b => {
                    let dist = Math.abs(this.x - b.x);
                    if (dist < 25) {
                        if (b.state === 'CLOSED' || b.state === 'OPENING' || b.state === 'CLOSING') {
                            this.handleCrash(true);
                        }
                    }
                });
            }

            if (this.x > canvas.width + 60 || this.x < -60) {
                this.dead = true;
                this.handleExit();
            }
        }

        handleMarketArrival() {
            this.dead = true;
            mood = Math.min(100, mood + 10);
            score += 150;
            playSound('arrive');
            createExplosion(this.x, this.y, 'üíñ'); 
            createFloatingText("Juhu!", this.x, this.y - 30, '#2ecc71');
            checkMood();
        }

        handleCrash(isBollardHit) {
            this.dead = true;
            createExplosion(this.x, this.y, 'üí•');

            if (this.category === 'good') {
                mood -= 15;
                playSound('crash');
                createFloatingText("NEIN!", this.x, this.y - 30, '#e74c3c');
                if (this.data.name === 'Tram') {
                    gameOver("Tramunfall! Verkehr tot.");
                }
            } else if (this.category === 'bad') {
                score += 50;
                playSound('success');
                createFloatingText("STOP!", this.x, this.y - 30, '#2ecc71');
            }
            checkMood();
        }

        handleExit() {
            if (this.category === 'good') {
                score += 100;
                createFloatingText("FREI!", this.x - (50*this.direction), this.y, '#2ecc71');
            } else if (this.category === 'bad') {
                mood -= 20;
                playSound('crash');
                createFloatingText("OHJE!", this.x - (50*this.direction), this.y, '#e74c3c');
                checkMood();
            } else {
                score += 10;
            }
        }

        draw() {
            if (this.dead) return;
            ctx.save();
            ctx.translate(this.x, this.y);
            if (this.direction === -1) ctx.scale(-1, 1); 
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.data.sprite, 0, 0);
            ctx.restore();
        }
    }

    /**
     * VISUALS
     */

    function createExplosion(x, y, char) {
        for(let i=0; i<6; i++) { // Fewer particles for mobile perf
            particles.push({
                x: x, y: y,
                vx: (Math.random()-0.5)*10,
                vy: (Math.random()-0.5)*10,
                life: 1.0,
                char: char,
                type: 'particle'
            });
        }
    }

    function createFloatingText(text, x, y, color) {
        particles.push({
            x: x, y: y,
            text: text,
            color: color,
            life: 1.0,
            vy: -1.5,
            type: 'text'
        });
    }

    function drawBackground() {
        ctx.fillStyle = '#34495e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(LEFT_BOLLARD_X, 0, RIGHT_BOLLARD_X - LEFT_BOLLARD_X, canvas.height);
        
        ctx.lineWidth = 6;
        ctx.strokeStyle = '#555';
        [TRACK_Y_1, TRACK_Y_2].forEach(y => {
            ctx.beginPath();
            ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
            ctx.stroke();
            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, y-8); ctx.lineTo(canvas.width, y-8);
            ctx.moveTo(0, y+8); ctx.lineTo(canvas.width, y+8);
            ctx.stroke();
        });

        ctx.font = '40px Arial';
        ctx.fillText('üéÑ', 400, 100);
        ctx.fillText('‚ú®', 300, 450);
        ctx.fillText('‚ú®', 500, 450);
    }

    /**
     * CORE FUNCTIONS & MOBILE INPUT
     */

    function init() {
        bollards = [
            new Bollard(LEFT_BOLLARD_X, TRACK_Y_1, 0),
            new Bollard(RIGHT_BOLLARD_X, TRACK_Y_1, 1), 
            new Bollard(LEFT_BOLLARD_X, TRACK_Y_2, 2), 
            new Bollard(RIGHT_BOLLARD_X, TRACK_Y_2, 3)  
        ];

        workers = [
            new Worker(1, 350, 250),
            new Worker(2, 450, 250)
        ];

        entities = [];
        particles = [];
        
        // Touch and Mouse support
        canvas.addEventListener('mousedown', handleInput);
        canvas.addEventListener('touchstart', handleInput, {passive: false});
        
        requestAnimationFrame(gameLoop);
    }

    function handleInput(e) {
        if(e.type === 'touchstart') e.preventDefault(); // Stop scrolling
        if (!gameRunning) return;
        playSound('click');

        // Calculate Scale Factor (Canvas Pixel Width vs CSS Width)
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        let clientX, clientY;
        if (e.changedTouches && e.changedTouches.length > 0) {
            clientX = e.changedTouches[0].clientX;
            clientY = e.changedTouches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        const clickX = (clientX - rect.left) * scaleX;
        const clickY = (clientY - rect.top) * scaleY;

        let clickedBollard = null;
        let minDist = 80; // Larger hit area for mobile

        bollards.forEach(b => {
            let d = Math.sqrt((clickX - b.x)**2 + (clickY - b.y)**2);
            if (d < minDist) {
                clickedBollard = b;
                minDist = d;
            }
        });

        if (clickedBollard) {
            if (clickedBollard.workingWorker) return;
            let idleWorkers = workers.filter(w => w.state === 'IDLE');
            if (idleWorkers.length > 0) {
                idleWorkers.sort((a,b) => {
                    let da = Math.sqrt((a.x - clickedBollard.x)**2 + (a.y - clickedBollard.y)**2);
                    let db = Math.sqrt((b.x - clickedBollard.x)**2 + (b.y - clickedBollard.y)**2);
                    return da - db;
                });
                idleWorkers[0].assignTask(clickedBollard);
            } else {
                createFloatingText("ALLE BUSY!", clickX, clickY, '#f1c40f');
            }
        }
    }

    function checkLevelUp() {
        if (eventsCount > 0 && eventsCount % 10 === 0) {
            level++;
            eventsCount++; 
            createFloatingText("LEVEL UP!", 400, 250, '#e67e22');
            playSound('levelup');
        }
    }

    function checkMood() {
        document.getElementById('mood-fill').style.width = Math.max(0, mood) + '%';
        if (mood <= 0) {
            gameOver("Stimmung am Ende!");
        }
    }

    function spawnLogic() {
        let rate = Math.max(40, 200 - (level * 20));
        if (frameCount % rate === 0) {
            entities.push(new GameEntity());
            eventsCount++;
            checkLevelUp();
        }
    }

    function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        lastTime = timestamp;

        if (gameRunning) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();

            frameCount++;
            spawnLogic();

            bollards.forEach(b => b.draw());
            
            entities.forEach((e, i) => {
                e.update();
                e.draw();
                if (e.dead) entities.splice(i, 1);
            });

            workers.forEach(w => {
                w.update();
                w.draw();
            });

            particles.forEach((p, i) => {
                if (p.type === 'particle') {
                    p.x += p.vx; p.y += p.vy; p.life -= 0.05;
                    ctx.globalAlpha = Math.max(0, p.life);
                    ctx.font = '20px Arial';
                    ctx.fillText(p.char, p.x, p.y);
                } else {
                    p.y += p.vy; p.life -= 0.02;
                    ctx.globalAlpha = Math.max(0, p.life);
                    ctx.font = '12px "Press Start 2P"'; // Mobile readable font
                    ctx.fillStyle = p.color;
                    ctx.fillText(p.text, p.x, p.y);
                }
                ctx.globalAlpha = 1.0;
                if (p.life <= 0) particles.splice(i, 1);
            });

            document.getElementById('score-display').innerText = Math.floor(score);
            document.getElementById('level-display').innerText = level;
        }

        requestAnimationFrame(gameLoop);
    }

    function gameOver(reason) {
        gameRunning = false;
        document.getElementById('final-reason').innerText = reason;
        document.getElementById('final-score').innerText = Math.floor(score);
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    function startGame() {
        score = 0;
        mood = 100;
        level = 1;
        eventsCount = 0;
        frameCount = 0;
        gameRunning = true;
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('mood-fill').style.width = '100%';
        
        workers[0].x = 350; workers[0].y = 250; workers[0].state='IDLE'; workers[0].targetBollard=null;
        workers[1].x = 450; workers[1].y = 250; workers[1].state='IDLE'; workers[1].targetBollard=null;
        
        entities = [];
        bollards.forEach(b => { b.state = 'CLOSED'; b.progress=0; b.workingWorker=null; });
        
        playSound('success');
    }

    // Touch Handling for Buttons
    const startBtn = document.getElementById('start-btn');
    startBtn.addEventListener('click', () => { init(); startGame(); });
    startBtn.addEventListener('touchstart', (e) => { e.preventDefault(); init(); startGame(); }, {passive: false});

    const restartBtn = document.getElementById('restart-btn');
    restartBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startGame(); }, {passive: false});

    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(0,0,800,500);

</script>
</body>
</html>