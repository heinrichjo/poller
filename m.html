<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Die Poller-Pumper retten Weihnachten (Mobile)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            font-family: 'Press Start 2P', cursive;
            color: white;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            height: 100dvh;
            width: 100vw;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #scaler {
            position: absolute;
            transform-origin: center center;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-wrapper {
            position: relative;
            width: 800px;
            height: 500px;
            background: #1a1a1a;
            border: 4px solid #c0392b;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI ELEMENTS */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            padding: 10px;
            padding-top: max(25px, env(safe-area-inset-top)); 
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 5; /* Base UI */
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-shadow: 2px 2px 0 #000;
            font-size: 14px;
            width: 100%;
            pointer-events: auto;
            background: rgba(0,0,0,0.3);
            padding: 5px;
            border-radius: 5px;
        }

        .weihnachts-meter { width: 150px; height: 15px; background: #555; border: 2px solid white; position: relative; }
        .meter-fill { width: 100%; height: 100%; background: #27ae60; transition: width 0.2s; }

        .btn-group { display: flex; gap: 10px; }

        .hud-btn {
            border: 2px solid #fff; color: white;
            padding: 5px 10px; font-size: 10px; cursor: pointer; pointer-events: auto;
            font-family: 'Press Start 2P', cursive;
        }
        #pause-btn { background: #f39c12; }
        #quit-btn { background: #c0392b; }

        /* NEWSTICKER - Hoher Z-Index damit sichtbar √ºber Pause */
        #news-ticker {
            position: absolute; bottom: 40px; left: 0; width: 100%; height: 25px;
            background: rgba(0, 0, 0, 0.85); color: #f1c40f;
            font-family: 'Arial', sans-serif; font-weight: bold; font-size: 12px;
            line-height: 25px; white-space: nowrap; overflow: hidden;
            border-top: 1px solid #c0392b; 
            z-index: 20; /* √úberlagert Overlay (z-10) */
            pointer-events: none;
        }
        #news-content { display: inline-block; padding-left: 100%; animation: ticker 140s linear infinite; }
        @keyframes ticker { 0% { transform: translate3d(0, 0, 0); } 100% { transform: translate3d(-100%, 0, 0); } }

        /* LEGEND */
        #legend {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 40px;
            background: #2c3e50; border-top: 2px solid #7f8c8d;
            display: flex; justify-content: space-around; align-items: center;
            font-size: 10px; z-index: 6; padding-bottom: max(5px, env(safe-area-inset-bottom));
        }
        .legend-section { display: flex; flex-direction: column; align-items: center; }
        .good { color: #2ecc71; } .bad { color: #e74c3c; }

        /* SCREENS */
        .screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
            z-index: 10; padding: 20px; box-sizing: border-box;
        }
        .hidden { display: none !important; }

        h1 { color: #e74c3c; line-height: 1.4; font-size: 24px; margin-bottom: 10px;}
        p { font-size: 10px; line-height: 1.6; max-width: 600px; margin-bottom: 15px; color: #ccc; }
        .story-text { color: #3498db; margin-bottom: 15px; font-style: italic;}
        
        .mode-select { display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap; justify-content: center; }

        button.main-btn {
            background: #27ae60; color: white; border: none; padding: 10px 20px;
            font-family: 'Press Start 2P', cursive; font-size: 12px;
            cursor: pointer; border-bottom: 4px solid #1e8449; margin: 5px;
        }
        button.main-btn:active { transform: translateY(4px); border-bottom: none; }
        button.secondary { background: #7f8c8d; border-bottom: 4px solid #555; }
        button.danger { background: #c0392b; border-bottom: 4px solid #922b21; }

        .rules-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
            text-align: left;
            font-size: 8px;
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
            width: 95%;
        }
        
        .rules-column h3 { color: #f1c40f; margin: 0 0 5px 0; font-size: 9px; border-bottom: 1px solid #555; padding-bottom: 2px;}
        .rules-item { margin-bottom: 2px; display: flex; align-items: center; }
        .emoji-icon { width: 15px; display: inline-block; font-size: 12px; text-align: center;}

        /* TUTORIAL */
        .tutorial-card {
            background: #34495e; border: 2px solid #ecf0f1; padding: 15px;
            border-radius: 10px; max-width: 500px; width: 90%;
            display: flex; flex-direction: column; align-items: center;
        }
        
        #tut-canvas {
            background: #2c3e50;
            border: 2px solid #7f8c8d;
            margin-bottom: 10px;
            border-radius: 5px;
        }

        .tutorial-text { font-size: 12px; color: #fff; margin-bottom: 15px; display: block; min-height: 40px;}
        .tut-feedback { font-size: 12px; font-weight: bold; margin-bottom: 10px; min-height: 20px; }

        /* CREATOR INFO */
        .creator-info {
            position: absolute; bottom: 10px; left: 0; width: 100%;
            text-align: center; font-size: 8px; color: #7f8c8d;
            margin-top: 20px;
        }

    </style>
</head>
<body>

<div id="scaler">
    <div id="game-wrapper">
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        
        <div id="ui-layer">
            <div class="hud-top">
                <div>LVL:<span id="level-display">1</span> SCR:<span id="score-display">0</span></div>
                <div class="weihnachts-meter-container">
                    LAUNE:
                    <div class="weihnachts-meter"><div id="mood-fill" class="meter-fill"></div></div>
                </div>
                <div class="btn-group">
                    <button id="pause-btn" class="hud-btn">PAUSE</button>
                    <button id="quit-btn" class="hud-btn">X</button>
                </div>
            </div>
        </div>

        <div id="news-ticker">
            <div id="news-content">
                +++ EILMELDUNG +++ Hohoho! Bald ist Weihnachten +++ VERKEHR: Linie 2 versp√§tet +++ ZOO: Rentiere ausgebrochen +++ SKANDAL: B√ºrgermeisterin beim Schwarzfahren erwischt +++ MARKT: Gl√ºhweinvorr√§te kritisch +++ NATUR: Rentiere an der Wertach entdeckt +++ ARCHITEKTUR: Bauruine neben dem Hotelturm hofft auf ein Weihnachtswunder +++ POLITIK: Rekordverd√§chtige Zustimmungsraten f√ºr den K√∂nig von Augsburg +++ NACHRICHTEN: Poller-Pumper fordern beheizte Hubwagen +++ AUGSBURG: Poller klemmt erneut - "Wir brauchen mehr Schmiermittel" +++
            </div>
        </div>

        <div id="legend">
            <div class="legend-section"><span class="good">DURCHLASSEN</span><div class="legend-icons">üöãüç∑üéÅüëº</div></div>
            <div class="legend-section"><span class="bad">STOPPEN</span><div class="legend-icons">ü•¥üë∫üëπüó£Ô∏è</div></div>
        </div>

        <!-- START SCREEN -->
        <div id="start-screen" class="screen-overlay">
            <h1>DIE POLLER-PUMPER<br>RETTEN WEIHNACHTEN</h1>
            
            <p class="story-text">
                Der Weihnachtsmarkt ist gef√§hrdet! Die Poller m√ºssen richtig bewegt werden, um das Fest zu retten. Jetzt m√ºssen <strong>DU und dein Team</strong> ran!
            </p>

            <div class="rules-grid">
                <div class="rules-column">
                    <h3 style="color:#2ecc71">DURCHLASSEN (TAP)</h3>
                    <div class="rules-item"><span class="emoji-icon">üöã</span> Tram</div>
                    <div class="rules-item"><span class="emoji-icon">üç∑</span> Essen/Wein <span class="emoji-icon">üç™</span></div>
                    <div class="rules-item"><span class="emoji-icon">üéÅ</span> Geschenke <span class="emoji-icon">üéÖ</span></div>
                    <div class="rules-item"><span class="emoji-icon">üëº</span> Christkind</div>
                </div>
                <div class="rules-column">
                    <h3 style="color:#e74c3c">STOPPEN (ZU)</h3>
                    <div class="rules-item"><span class="emoji-icon">ü•¥</span> Suffkis</div>
                    <div class="rules-item"><span class="emoji-icon">üë∫</span> Diebe</div>
                    <div class="rules-item"><span class="emoji-icon">üó£Ô∏è</span> Schwurbler</div>
                    <div class="rules-item"><span class="emoji-icon">üëπ</span> Griesgrame</div>
                </div>
            </div>

            <p>
                Tippe auf die Poller!<br>
                Tipp: Handy quer halten!
            </p>
            <div class="mode-select">
                <button class="main-btn" onclick="checkTutorial('AUGSBURG')">AUGSBURG</button>
                <button class="main-btn" onclick="checkTutorial('CLASSIC')">KLASSIK</button>
                <button class="main-btn" onclick="checkTutorial('HYDRAULIC')">AUTOMATIK</button>
            </div>
            
            <div class="creator-info">
                Erstellt von Johannes Heinrich mit der Unterst√ºtzung von Gemini - 2025
            </div>
        </div>

        <!-- TUTORIAL SCREEN -->
        <div id="tutorial-screen" class="screen-overlay hidden">
            <div class="tutorial-card">
                <!-- Mini Canvas for Animations -->
                <canvas id="tut-canvas" width="200" height="120"></canvas>
                
                <span id="tut-text" class="tutorial-text">...</span>
                <div id="tut-feedback" class="tut-feedback"></div>
                
                <div id="tut-controls">
                    <button class="main-btn" id="tut-btn-open" onclick="handleTutorialChoice(true)">POLLERN (AUF)</button>
                    <button class="main-btn danger" id="tut-btn-close" onclick="handleTutorialChoice(false)">BLOCKIEREN (ZU)</button>
                </div>
                <div style="margin-top:10px">
                    <button class="main-btn secondary" onclick="skipTutorial()">DIENST BEGINNEN</button>
                </div>
            </div>
        </div>

        <!-- PAUSE SCREEN -->
        <div id="pause-screen" class="screen-overlay hidden">
            <h1>PAUSE</h1>
            <p>Die Pumper machen Brotzeit.</p>
            <button class="main-btn" onclick="togglePause()">WEITERMACHEN</button>
            <button class="main-btn secondary" onclick="location.reload()">BEENDEN</button>
        </div>

        <!-- GAME OVER SCREEN -->
        <div id="game-over-screen" class="screen-overlay hidden">
            <h1 id="go-title">SCHICHTENDE!</h1>
            <h2 id="final-reason">...</h2>
            <p style="margin-top:10px;">Frohe Weihnachten!</p>
            <p>Score: <span id="final-score">0</span></p>
            <button class="main-btn" onclick="location.reload()">NEUER DIENST</button>
        </div>
    </div>
</div>

<script>
    /* --- RESIZE LOGIC --- */
    function resizeGame() {
        const wrapper = document.getElementById('game-wrapper');
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        const scale = Math.min(winW / 800, winH / 500);
        wrapper.style.transform = `scale(${scale})`;
    }
    window.addEventListener('resize', resizeGame);
    resizeGame();

    /* --- AUDIO --- */
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'click') { osc.frequency.value=300; gainNode.gain.value=0.05; osc.start(now); osc.stop(now+0.1); }
        if (type === 'pump') { osc.type='sawtooth'; osc.frequency.value=60; gainNode.gain.value=0.05; osc.start(now); osc.stop(now+0.1); }
        if (type === 'crash') { osc.type='square'; osc.frequency.exponentialRampToValueAtTime(20, now+0.3); gainNode.gain.value=0.2; osc.start(now); osc.stop(now+0.3); }
        if (type === 'success') { osc.type='sine'; osc.frequency.setValueAtTime(500, now); osc.frequency.linearRampToValueAtTime(1000, now+0.2); gainNode.gain.value=0.05; osc.start(now); osc.stop(now+0.2); }
    }

    /* --- ENGINE --- */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Config - MOVED BOLLARDS CLOSER TO CENTER (280/520)
    const TRACK_Y_1 = 180, TRACK_Y_2 = 350;
    const LEFT_BOLLARD_X = 280, RIGHT_BOLLARD_X = 520;
    const MARKET_CENTER_X = 400;
    const WORKER_SPEED_BASE = 250; 
    const PUMP_TIME = 0.5; 
    const MOVE_TIME = 0.7; 
    const ENTITY_SPEED_BASE = 80;

    // State
    let lastTime = 0;
    let gameState = 'MENU'; 
    let gameMode = 'CLASSIC';
    let score=0, mood=100, level=1, eventsCount=0, frameCount=0, autoWinTimer=0;
    let workers=[], bollards=[], entities=[], particles=[];
    
    // Intro State
    let introPhase = 0; 
    let santaX = -100;

    // Assets
    const ASSETS = {
        good: [
            { sprite: 'üöã', name: 'Tram' }, { sprite: 'üç™', name: 'Lebkuchen' },
            { sprite: 'üéÅ', name: 'Geschenk' }, { sprite: 'üç∑', name: 'Gl√ºhwein' },
            { sprite: 'üëº', name: 'Christkind' }, { sprite: 'üéÖ', name: 'Santa' }
        ],
        bad: [
            { sprite: 'ü•¥', name: 'Betrunkener' }, { sprite: 'üó£Ô∏è', name: 'Schwurbler' },
            { sprite: 'üë∫', name: 'Dieb' }, { sprite: 'üëπ', name: 'Griesgram' } 
        ],
        jump: [{ sprite: 'ü¶å', name: 'Rentier' }],
        worker: 'üë∑', workerBusy: 'üèóÔ∏è',
        bollardClosed: 'üóø', bollardOpen: 'üï≥Ô∏è'
    };

    /* --- TUTORIAL LOGIC & ANIMATION --- */
    const TUT_DATA = [
        { e: 'üöã', t: 'Die TRAM! Sie muss durchfahren.', action: true },
        { e: 'ü•¥', t: 'Ein SUFFKI! P√∂belt rum.', action: false },
        { e: 'üç∑', t: 'GL√úHWEIN! Muss zum Markt.', action: true },
        { e: 'üó£Ô∏è', t: 'Ein SCHWURBLER! Nervt alle.', action: false },
        { e: 'üë∫', t: 'Ein DIEB! Will klauen.', action: false }
    ];
    let tutIndex = 0;
    let tutAnimRunning = false;
    const tutCanvas = document.getElementById('tut-canvas');
    const tutCtx = tutCanvas.getContext('2d');
    let tutBollard = null;
    let tutWorker = null;

    function checkTutorial(mode) {
        gameMode = mode;
        document.getElementById('start-screen').classList.add('hidden');
        
        // Session Check
        if (sessionStorage.getItem('tut_seen') === 'true' || mode === 'HYDRAULIC') {
            startIntro();
        } else {
            startTutorial();
        }
    }

    function startTutorial() {
        gameState = 'TUTORIAL';
        tutIndex = 0;
        document.getElementById('tutorial-screen').classList.remove('hidden');
        sessionStorage.setItem('tut_seen', 'true');
        loadTutStep();
        requestAnimationFrame(tutLoop);
    }

    function loadTutStep() {
        const step = TUT_DATA[tutIndex];
        document.getElementById('tut-text').innerText = step.t;
        document.getElementById('tut-feedback').innerText = "";
        
        tutBollard = new Bollard(100, 80, 0); 
        tutWorker = new Worker(0, 150, 80);
        tutWorker.state = 'IDLE';
        tutWorker.x = 150; tutWorker.targetX = 150;
        tutAnimRunning = false;
    }

    function handleTutorialChoice(choice) {
        if(tutAnimRunning) return;
        const step = TUT_DATA[tutIndex];
        const feedback = document.getElementById('tut-feedback');
        
        if (choice === step.action) {
            feedback.innerText = "Richtig!";
            feedback.style.color = "#2ecc71";
            tutAnimRunning = true;
            if (choice === true) {
                tutWorker.assignTask(tutBollard);
                let prevMode = gameMode; gameMode = 'AUGSBURG'; 
                setTimeout(() => { gameMode = prevMode; nextTutStep(); }, 2000); 
            } else setTimeout(nextTutStep, 1000);
        } else {
            feedback.innerText = "Falsch! Denk nach!";
            feedback.style.color = "#e74c3c";
            playSound('crash');
        }
    }

    function nextTutStep() {
        tutIndex++;
        if (tutIndex >= TUT_DATA.length) skipTutorial();
        else loadTutStep();
    }

    function skipTutorial() {
        document.getElementById('tutorial-screen').classList.add('hidden');
        sessionStorage.setItem('tut_seen', 'true');
        startIntro();
    }

    function tutLoop(timestamp) {
        if (gameState !== 'TUTORIAL') return;
        let dt = 0.016; 

        tutCtx.fillStyle = '#34495e'; tutCtx.fillRect(0, 0, 200, 120);
        tutCtx.strokeStyle = '#555'; tutCtx.lineWidth=4;
        tutCtx.beginPath(); tutCtx.moveTo(0,80); tutCtx.lineTo(200,80); tutCtx.stroke();

        const step = TUT_DATA[tutIndex];
        tutCtx.font = '30px Arial'; tutCtx.textAlign='center'; tutCtx.textBaseline='middle';
        tutCtx.fillText(step.e, 30, 80);

        if (tutAnimRunning && step.action === true) {
            tutWorker.update(dt); 
            let sprite = tutWorker.state === 'WORKING' ? ASSETS.workerBusy : ASSETS.worker;
            // Tut worker needs Y offset too in Augsburg
            let wY = tutWorker.y;
            if (gameMode === 'AUGSBURG' && tutWorker.targetBollard) {
                 wY = tutWorker.targetBollard.y + tutWorker.targetBollard.sideOffset; 
                 if(tutWorker.targetBollard.sideOffset !== 0) wY += 20; 
            }
            tutCtx.fillText(sprite, tutWorker.x, wY);

            let b = tutBollard;
            let bSprite = ASSETS.bollardClosed;
            if(b.state==='OPEN') { bSprite = 'üóø'; tutCtx.fillText('üï≥Ô∏è', b.originX, b.y); }
            else if (b.state.includes('MOVE') || b.state==='UP') tutCtx.fillText('üï≥Ô∏è', b.originX, b.y);
            
            let liftY = 0;
            if (b.state === 'PUMP_UP') liftY = -10;
            if (b.state.includes('MOVE')) liftY = -10;
            
            tutCtx.fillText(bSprite, b.x, b.y + b.sideOffset + liftY);
        } else {
            tutCtx.fillText(ASSETS.worker, 150, 80);
            tutCtx.fillText(ASSETS.bollardClosed, 100, 80);
        }
        requestAnimationFrame(tutLoop);
    }

    /* --- CLASSES --- */
    class Bollard {
        constructor(x, y, id) {
            this.x = x; this.originX = x; this.y = y; this.id = id;
            this.state = 'CLOSED'; 
            this.progress = 0;
            this.workingWorker = null;
            this.sideOffset = 0; // Vertical offset for Augsburg mode
            this.moveDir = 1; 
        }
        draw() {
            if (gameState === 'INTRO' && introPhase < 1) return; 

            let color = '#7f8c8d';
            if (this.state === 'OPEN') color = '#27ae60';
            if(this.state.includes('PUMP') || this.state.includes('MOVE') || this.state.includes('ING')) ctx.fillStyle = '#f39c12';
            else ctx.fillStyle = color;
            
            // Progress Bar
            if (this.progress > 0) {
                ctx.fillStyle = '#f1c40f'; ctx.fillRect(this.originX-20, this.y-65, 40, 6);
                ctx.fillStyle = '#c0392b'; 
                let maxP = this.state.includes('MOVE') ? MOVE_TIME : PUMP_TIME;
                ctx.fillRect(this.originX-20, this.y-65, 40*(this.progress/maxP), 6);
            }

            let drawY = this.y + this.sideOffset;
            let sprite = ASSETS.bollardClosed;

            if (this.state === 'OPEN') {
                sprite = ASSETS.bollardOpen; 
                if (gameMode === 'AUGSBURG') {
                    ctx.font = '30px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('üï≥Ô∏è', this.originX, this.y); 
                    sprite = 'üóø'; 
                }
            } else if (gameMode === 'AUGSBURG' && (this.state.includes('MOVE') || this.state === 'UP')) {
                ctx.font = '30px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('üï≥Ô∏è', this.originX, this.y);
            }

            ctx.font = '30px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            let liftY = 0;
            if (gameMode === 'AUGSBURG') {
                if (this.state === 'PUMP_UP') liftY = -15 * (this.progress/PUMP_TIME);
                else if (this.state === 'PUMP_DOWN') liftY = -15 * (1-(this.progress/PUMP_TIME));
                else if (this.state !== 'CLOSED' && this.state !== 'OPEN') liftY = -15;
            }
            ctx.fillText(sprite, this.x, drawY + liftY);

            ctx.fillStyle = '#ecf0f1'; ctx.font = '8px "Press Start 2P"';
            ctx.fillText((this.state==='CLOSED')?"ZU":(this.state==='OPEN'?"AUF":"..."), this.originX, this.y+30);
        }
    }

    class Worker {
        constructor(id, x, y) {
            this.id = id; this.x = x; this.y = y; this.targetX = x; this.targetY = y;
            this.targetBollard = null; this.state = 'IDLE'; 
        }
        assignTask(bollard) {
            this.targetBollard = bollard; this.targetX = bollard.x; this.targetY = bollard.y - 20; 
            this.state = 'MOVING'; bollard.workingWorker = this;
        }
        update(dt) {
            const dx = this.targetX - this.x; const dy = this.targetY - this.y; const dist = Math.sqrt(dx*dx + dy*dy);
            const step = WORKER_SPEED_BASE * dt;
            
            if (dist > step) { this.x += (dx/dist)*step; this.y += (dy/dist)*step; }
            else { this.x = this.targetX; this.y = this.targetY; if(this.targetBollard && this.state==='MOVING') this.state='WORKING'; }

            if (this.state === 'WORKING' && this.targetBollard) {
                let effectiveMode = (gameState === 'TUTORIAL') ? 'AUGSBURG' : gameMode;
                if (effectiveMode === 'AUGSBURG') this.handleAugsburg(this.targetBollard, dt);
                else this.handleClassic(this.targetBollard, dt);
            }
        }
        handleClassic(b, dt) {
            if(b.state==='CLOSED') b.state='OPENING'; if(b.state==='OPEN') b.state='CLOSING';
            if(b.state.includes('ING')) {
                b.progress += dt; 
                if(b.progress>=PUMP_TIME) { b.state = (b.state==='OPENING')?'OPEN':'CLOSED'; b.progress=0; this.finishJob(b); }
            }
        }
        handleAugsburg(b, dt) {
            // Logic: PUMP_UP -> MOVE_SIDE (Y-Axis) -> OPEN
            if (b.state === 'CLOSED') b.state = 'PUMP_UP'; else if (b.state === 'OPEN') b.state = 'MOVE_BACK';
            
            if (b.state === 'PUMP_UP') {
                b.progress += dt;
                if (b.progress >= PUMP_TIME) { b.progress = 0; b.state = 'MOVE_SIDE'; }
            }
            else if (b.state === 'MOVE_SIDE') {
                b.progress += dt;
                let moveDist = 50 * (dt/MOVE_TIME); 
                b.sideOffset += moveDist; // Move Down
                this.y = b.y + b.sideOffset - 20; // Worker follows Y
                if (b.progress >= MOVE_TIME) { b.progress = 0; b.state = 'OPEN'; this.finishJob(b); }
            }
            else if (b.state === 'MOVE_BACK') {
                b.progress += dt;
                let moveDist = 50 * (dt/MOVE_TIME); 
                b.sideOffset -= moveDist; // Move Up
                this.y = b.y + b.sideOffset - 20; 
                if (b.progress >= MOVE_TIME) { b.progress = 0; b.sideOffset = 0; b.state = 'PUMP_DOWN'; }
            }
            else if (b.state === 'PUMP_DOWN') {
                b.progress += dt;
                if (b.progress >= PUMP_TIME) { b.progress = 0; b.state = 'CLOSED'; this.finishJob(b); }
            }
        }
        finishJob(b) { b.workingWorker = null; this.state = 'IDLE'; this.targetBollard = null; }
        draw() {
            if (gameState === 'INTRO' && introPhase < 2) return;
            ctx.font = '24px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            let sprite = this.state === 'WORKING' ? ASSETS.workerBusy : ASSETS.worker;
            ctx.fillText(sprite, this.x, this.y);
        }
    }

    class GameEntity {
        constructor() {
            this.lane = Math.floor(Math.random() * 2); this.y = this.lane === 0 ? TRACK_Y_1 : TRACK_Y_2;
            this.direction = Math.random() < 0.5 ? 1 : -1;
            this.x = this.direction === 1 ? -50 : canvas.width + 50;
            
            let r = Math.random();
            if (r < 0.1) { this.category = 'jump'; this.data = ASSETS.jump[0]; }
            else if (r < 0.55) { this.category = 'good'; this.data = ASSETS.good[Math.floor(Math.random()*ASSETS.good.length)]; }
            else { this.category = 'bad'; this.data = ASSETS.bad[Math.floor(Math.random()*ASSETS.bad.length)]; }
            
            if (Math.random() < 0.35) { this.category = 'good'; this.data = ASSETS.good[0]; }

            // Fixed Base Speed Logic (Pixels Per Second)
            // Start at 80, add 5 per level. Trams 60% of speed.
            let speedFactor = (ENTITY_SPEED_BASE + (level * 5)) * (this.data.name==='Tram'?0.6:1.0); 
            
            this.speed = speedFactor;
            this.dead = false;
        }
        update(dt) {
            if(this.dead) return;
            this.x += this.speed * this.direction * dt;

            // --- ZEN MODE AI ---
            // Zen Mode logic is now handled in gameLoop to see ALL entities
            
            if ((this.category==='good' && this.data.name!=='Tram') || this.category==='bad') {
                if(Math.abs(this.x-MARKET_CENTER_X)<10) { 
                    this.category==='good' ? this.arrive() : this.intrude(); 
                    return; 
                }
            }

            if(this.category!=='jump') {
                bollards.filter(b=>Math.abs(b.y-this.y)<20).forEach(b=>{
                    // Check collision against ORIGIN (where they try to pass)
                    if(Math.abs(this.x-b.originX)<30 && b.state!=='OPEN') this.crash();
                });
            }
            if(this.x>canvas.width+60||this.x<-60) { this.dead=true; this.exit(); }
        }
        arrive() { this.dead=true; mood=Math.min(100,mood+10); score+=150; playSound('arrive'); createExplosion(this.x,this.y,'üíñ'); checkMood(); }
        intrude() { this.dead=true; mood-=20; score=Math.max(0,score-100); playSound('crash'); createFloatingText("OHJE! -100",this.x,this.y-30,'#e74c3c'); checkMood(); }
        crash() { 
            this.dead=true; createExplosion(this.x,this.y,'üí•'); 
            if(this.category==='good') { mood-=15; playSound('crash'); if(this.data.name==='Tram') gameOver("Tramunfall! Verkehr tot."); }
            else { score+=50; playSound('success'); createFloatingText("STOP!",this.x,this.y-30,'#2ecc71'); }
            checkMood();
        }
        exit() {
            if(this.category==='good') { 
                score+=100; 
                if(this.data.name === 'Tram') {
                    score += 50; // Bonus for tram
                    createFloatingText("TRAM DURCH! +150", this.x - (50*this.direction), this.y, '#2ecc71');
                } else {
                    createFloatingText("FREI!",this.x,this.y,'#2ecc71'); 
                }
            }
            else if(this.category==='bad') { mood-=20; score=Math.max(0,score-100); checkMood(); }
        }
        draw() {
            if(this.dead) return;
            ctx.save(); ctx.translate(this.x, this.y); if(this.direction===-1) ctx.scale(-1,1);
            ctx.font='30px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(this.data.sprite,0,0);
            ctx.restore();
        }
    }

    function createExplosion(x,y,c) { for(let i=0;i<5;i++) particles.push({x:x,y:y,vx:(Math.random()-0.5)*100,vy:(Math.random()-0.5)*100,life:1,char:c,type:'p'}); }
    function createFloatingText(t,x,y,c) { particles.push({x:x,y:y,text:t,color:c,life:1,vy:-50,type:'t'}); }
    function checkMood() { document.getElementById('mood-fill').style.width=mood+'%'; if(mood<=0) gameOver("Stimmung am Ende!"); }

    function togglePause() {
        if (gameState==='PLAY') { gameState='PAUSE'; document.getElementById('pause-screen').classList.remove('hidden'); }
        else if (gameState==='PAUSE') { gameState='PLAY'; document.getElementById('pause-screen').classList.add('hidden'); lastTime = performance.now(); }
    }

    /* --- INTRO & GAME LOOP --- */
    function startIntro() {
        bollards = [
            new Bollard(LEFT_BOLLARD_X, TRACK_Y_1, 0), new Bollard(RIGHT_BOLLARD_X, TRACK_Y_1, 1),
            new Bollard(LEFT_BOLLARD_X, TRACK_Y_2, 2), new Bollard(RIGHT_BOLLARD_X, TRACK_Y_2, 3)
        ];
        workers = [ new Worker(1, -50, 250), new Worker(2, 850, 250) ];
        workers[0].finalX = 350; workers[1].finalX = 450;
        
        entities = []; score=0; mood=100; level=1; eventsCount=0; autoWinTimer=0;
        
        gameState = 'INTRO';
        introPhase = 0;
        santaX = -100;
        playSound('success');
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    function drawMarket() {
        ctx.fillStyle='#2c3e50'; ctx.fillRect(LEFT_BOLLARD_X,0,RIGHT_BOLLARD_X-LEFT_BOLLARD_X,canvas.height);
        ctx.font='80px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('üéÑ', 400, 250);
        ctx.font='50px Arial'; ctx.fillText('üõñ', 300, 270); ctx.fillText('üõñ', 500, 270);
        ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(350, 100, 2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(450, 150, 3, 0, Math.PI*2); ctx.fill();
    }

    let spawnTimer = 0;

    function updateZenAI() {
        if (gameMode !== 'HYDRAULIC') return;
        
        bollards.forEach(b => {
            // Find relevant entities on this lane
            let relevantEntities = entities.filter(e => Math.abs(e.y - b.y) < 20 && !e.dead);
            let closest = null;
            let minDist = 9999;

            relevantEntities.forEach(e => {
                // Check dist to BOLLARD ORIGIN
                let dist = (b.originX - e.x) * e.direction; // Positive if approaching
                // Logic: 
                // Approaching (>0) AND close (<200) -> Open
                // Leaving (<0) AND close (>-100) -> Keep Open (for Tram exit)
                
                // We want the entity that dictates the state. Usually the closest one.
                // But we must prioritize "inside" entities leaving if they are Trams.
                
                // Simple logic: Is there ANY good entity needing passage nearby?
                // Passage needed if:
                // 1. Approaching (dist > 0 && dist < 200)
                // 2. Leaving (dist < 0 && dist > -100) (Tram leaving market)
                
                // Absolute distance check for general proximity
                let absDist = Math.abs(b.originX - e.x);
                
                if (absDist < minDist) {
                    minDist = absDist;
                    closest = e;
                }
            });

            if (closest) {
                // Determine if we need to open based on the closest entity
                let dist = (b.originX - closest.x) * closest.direction;
                
                let isGood = (closest.category === 'good' && closest.category !== 'jump');
                let isTramLeaving = (isGood && dist < 0 && dist > -100);
                let isApproaching = (dist > 20 && dist < 220);

                if (isGood) {
                    if (isApproaching || isTramLeaving) {
                        if (b.state === 'CLOSED') b.state = 'OPENING';
                    } else if (dist < -100 || dist > 250) {
                        if (b.state === 'OPEN') b.state = 'CLOSING';
                    }
                } else {
                    // Bad guy
                    if (isApproaching) {
                        if (b.state === 'OPEN') b.state = 'CLOSING';
                    }
                }
            } else {
                // No entities nearby, default close
                if (b.state === 'OPEN') b.state = 'CLOSING';
            }
        });
    }

    function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 1000; 
        lastTime = timestamp;
        const safeDt = Math.min(dt, 0.1);

        if(gameState==='PLAY' || gameState==='HYDRAULIC_RUN' || gameState==='INTRO') {
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle='#34495e'; ctx.fillRect(0,0,canvas.width,canvas.height);
            drawMarket(); 
            ctx.lineWidth=6; ctx.strokeStyle='#555'; [TRACK_Y_1,TRACK_Y_2].forEach(y=>{ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();});

            if(gameState === 'INTRO') {
                ctx.font='60px Arial'; ctx.fillText('üéÖüõ∑', santaX, 100);
                santaX += 200 * safeDt;
                if(santaX > 400 && introPhase === 0) { introPhase = 1; playSound('pump'); } 
                if(santaX > 900) introPhase = 2; 

                if (introPhase === 2) {
                    workers.forEach(w => { w.targetX = w.finalX; w.update(safeDt); w.draw(); });
                    if (Math.abs(workers[0].x - 350) < 5 && Math.abs(workers[1].x - 450) < 5) {
                        gameState = 'PLAY';
                        createFloatingText("LOS GEHT'S!", 400, 250, '#f1c40f');
                    }
                }
            } 
            else {
                if(gameMode==='HYDRAULIC') {
                    autoWinTimer += safeDt;
                    updateZenAI(); 
                    if(autoWinTimer > 180) { gameOver("Hydraulik-Sieg! Alle happy."); document.getElementById('go-title').innerText="GEWONNEN"; }
                }
                
                spawnTimer += safeDt;
                let spawnInterval = Math.max(2.0, 5.0 - (level * 0.2));
                
                if (spawnTimer > spawnInterval) {
                    spawnTimer = 0;
                    entities.push(new GameEntity()); 
                    eventsCount++; 
                    if(eventsCount%10===0){level++; createFloatingText("LEVEL UP!",400,250,'#e67e22'); playSound('levelup');}
                }

                entities.forEach((e,i)=>{e.update(safeDt);e.draw();if(e.dead)entities.splice(i,1)});
                if(gameMode!=='HYDRAULIC') workers.forEach(w=>{w.update(safeDt);w.draw()});
            }

            bollards.forEach(b=>{
                if(gameMode==='HYDRAULIC') {
                    if(b.state==='OPENING'){b.progress+=safeDt;if(b.progress>=PUMP_TIME){b.state='OPEN';b.progress=0;}}
                    if(b.state==='CLOSING'){b.progress+=safeDt;if(b.progress>=PUMP_TIME){b.state='CLOSED';b.progress=0;}}
                }
                b.draw();
            });

            particles.forEach((p,i)=>{
                p.type==='p' ? (p.x+=p.vx*safeDt, p.y+=p.vy*safeDt, ctx.font='20px Arial', ctx.fillText(p.char,p.x,p.y)) : (p.y+=p.vy*safeDt, ctx.font='12px "Press Start 2P"', ctx.fillStyle=p.color, ctx.fillText(p.text,p.x,p.y));
                p.life-=1.0 * safeDt; ctx.globalAlpha=Math.max(0, p.life); if(p.life<=0)particles.splice(i,1); ctx.globalAlpha=1;
            });

            document.getElementById('score-display').innerText=Math.floor(score);
            document.getElementById('level-display').innerText=level;
        }
        requestAnimationFrame(gameLoop);
    }

    function handleInput(e) {
        if (e.type === 'touchstart') e.preventDefault();
        if(gameState!=='PLAY') return;
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const scale = 800 / rect.width;
        const clickX = (clientX - rect.left) * scale;
        const clickY = (clientY - rect.top) * scale;

        let clickedBollard = null;
        bollards.forEach(b => { if(Math.sqrt((clickX-b.originX)**2 + (clickY-b.y)**2) < 80) clickedBollard = b; });

        if(clickedBollard && !clickedBollard.workingWorker) {
            playSound('click');
            let idleWorkers = workers.filter(w=>w.state==='IDLE');
            if(idleWorkers.length>0) {
                idleWorkers.sort((a,b)=>Math.abs(a.x-clickedBollard.originX)-Math.abs(b.x-clickedBollard.originX));
                idleWorkers[0].assignTask(clickedBollard);
            } else createFloatingText("ALLE BUSY!", clickX, clickY, '#f1c40f');
        }
    }

    function gameOver(reason) {
        gameState='GAMEOVER';
        document.getElementById('final-reason').innerText=reason + " Frohe Weihnachten!";
        document.getElementById('final-score').innerText=Math.floor(score);
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    // Buttons
    document.getElementById('pause-btn').addEventListener('click', togglePause);
    document.getElementById('quit-btn').addEventListener('click', () => location.reload()); // Quit
    
    // Canvas
    canvas.addEventListener('mousedown', handleInput);
    canvas.addEventListener('touchstart', handleInput, {passive: false});
    ctx.fillStyle='#2c3e50'; ctx.fillRect(0,0,800,500);
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
